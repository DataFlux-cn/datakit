package mysql

type customerMeasurement struct {
	client  *sql.DB
	name    string
	tags    map[string]string
	fields  map[string]interface{}
	ts      time.Time
	resData map[string]interface{}
}

// 生成行协议
func (m *customerMeasurement) LineProto() (*io.Point, error) {
	return io.MakePoint(m.name, m.tags, m.fields, m.ts)
}

// 指定指标
func (m *customerMeasurement) Info() *inputs.MeasurementInfo {
	return &inputs.MeasurementInfo{
		Name:   "mysql_customer",
		Fields: map[string]*inputs.FieldInfo{},
		Tags: map[string]*inputs.TagInfo{
			"server": &inputs.TagInfo{
				Desc: "server addr",
			},
		},
	}
}

func (i *Input) exec() {
	for key, item := range metricMap {
		resMap, err := i.query(item)
		if err != nil {
			l.Warnf("mysql query faild %v", err)
		}

		m.handleResponse(servtag, resMap)
	}
}

func (i *Input) handleResponse() error {
	for _, item := range i.response {
		m := &customerMeasurement{
			name:   "mysql_customer",
			tags:   make(map[string]string),
			fields: make(map[string]interface{}),
		}

		for key, value := range i.Tags {
			m.tags[key] = value
		}

		m.fields = item
		m.ts = time.Now()

		i.collectCache = append(i.collectCache, m)
	}

	return nil
}

func (i *Input) query(sql string) ([]map[string]interface{}, error) {
	rows, err := i.client.Query(sql)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columns, _ := rows.Columns()
	columnLength := len(columns)
	cache := make([]interface{}, columnLength)
	for idx, _ := range cache {
		var a interface{}
		cache[idx] = &a
	}
	var list []map[string]interface{}
	for rows.Next() {
		_ = rows.Scan(cache...)

		item := make(map[string]interface{})
		for i, data := range cache {
			key := strings.ToLower(columns[i])
			val := *data.(*interface{})

			if val != nil {
				vType := reflect.TypeOf(val)

				switch vType.String() {
				case "int64":
					item[key] = val.(int64)
				case "string":
					var data interface{}
					data, err := strconv.ParseFloat(val.(string), 64)
					if err != nil {
						data = val
					}
					item[key] = data
				case "time.Time":
					item[key] = val.(time.Time)
				case "[]uint8":
					item[key] = string(val.([]uint8))
				default:
					return nil, fmt.Errorf("unsupport data type '%s' now\n", vType)
				}
			}
		}

		list = append(list, item)
	}
	return list, nil
}
